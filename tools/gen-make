#!/usr/bin/python3.7

import argparse
import os
import subprocess
import sys

#----------------------- Class IO -----------------------#
class IO:
    tag_id = {
                "C":"CMD",      # Command tag
                "E":"ERROR",    # Error tag
                "F":"FAIL",     # Fail tag
                "I":"INFO",     # Info tag
                "W":"WARN"      # Warning tag
            }

    @staticmethod
    def log(mode, msg):
        tag = IO.tag_id.get(mode)
        if(tag == None):
            raise Exception("unknown mode \`" + mode + "' specified")
        
        print("|%s| %s" %(tag, msg))

    @staticmethod
    def cmdOut(msg):
        for line in msg.split('\n'):
            print(" >  " + line)

    @staticmethod
    def fileAppend(fd, msg, line_end='\n'):
        print(msg, end=line_end, file=fd)

#----------------------- Class Args -----------------------#
class Args:
    __parser = argparse.ArgumentParser()

    def __init__(self):
        self.__parser.add_argument("file", help="genrate Makefile for this file")
        self.__parser.add_argument("-d", dest="cDir", metavar="dir", default=".", help="alternate location of file if not current directory")
        self.__parser.add_argument("-i", dest="incDir", metavar="dir", action="append", help="path of include directory")
        self.__parser.add_argument("-s", dest="srcDir", metavar="dir", action="append", help="path to source directory")

    def parse(self):
        return self.__parser.parse_args()


#----------------------- Class Rules -----------------------#
class Rules:
    src_list = []
    inc_list = []
    obj_list = []
    node = {}
    makefile = ''

    def write(self, msg, end='\n'):
        IO.fileAppend(self.makefile, msg, end)

    #---------------------------------------------------------------------#
    # Takes file paths that exists and returns all existing include files #
    #---------------------------------------------------------------------#
    def allIncludes(self, file):
        includes = dict()
        for line in open(file, 'r').readlines():
            if (line.startswith("#include") and len(line.split('"')) > 1):
                inc_file = line.split('"')[1]
                dir = self.findDir(self.inc_list, inc_file)
                if(dir):
                    includes[inc_file] = dir
                else:
                    IO.log('W', "included file " + inc_file + " does not exist")
        return includes

    #------------------------------------------#
    # Find all the depeds for a file from node #
    #------------------------------------------#
    def allDepends(self, file):
        l = [file]
        try:
            for dep in self.node[file]:
                l += self.allDepends(dep)
        finally:
            return l

    #-----------------------------------------------#
    # Returns dir of the file from the lookup given #
    #-----------------------------------------------#
    def findDir(self, lookup, file):
        if(os.path.exists(file)):
            return file
        for dir in lookup:
            if(os.path.exists(dir + '/' + file)):
                return dir
        return None

    #------------------------------------------------#
    # Converts .h file to .cc and check if it exists #
    #------------------------------------------------#
    def h2cc(self, h_file):
        cc = h_file.replace(".h", ".cc")
        dir = self.findDir(self.src_list, cc)
        if(dir):
            return dir, cc
        return None, None

    #-------------------------------------------------#
    # Converts .cc to .o and return its path for make #
    #-------------------------------------------------#
    def cc2o(self, dir, file):
        obj_dir = '$(OBJ_LOCAL)'
        if dir in self.src_list:
            obj_dir = '$(OBJ_COMMON)'
        dot_o = obj_dir + '/' + file.replace(".cc", ".o")
        return dot_o

    #----------------------------------#
    # Create rules in recursive manner #
    #----------------------------------#
    def createRule(self, dir, file):
        complete_file = dir + '/' + file
        if(complete_file in self.node):
            return None
        if(not complete_file):
            return None

        incs = self.allIncludes(complete_file)
        inc_list = []
        for inc_file, inc_dir in incs.items():
            inc_list.append(inc_dir + '/' + inc_file)

        self.node[complete_file] = inc_list
        ret_list = set()
        for inc_file, inc_dir in incs.items():
            ret = self.createRule(inc_dir, inc_file)

        if(file.endswith(".h")):
            src_dir, src_file = self.h2cc(file)
            if(src_dir and src_file):
                ret = self.createRule(src_dir, src_file)
                if(ret):
                    ret_list.union(ret)
        elif(file.endswith(".cc")):
            dot_o = self.cc2o(dir, file)
            self.obj_list.append(dot_o)
            self.write(dot_o + ": " + complete_file + ' ', '')
            for inc_file, inc_dir in incs.items():
                self.write(' '.join(self.allDepends(inc_dir + '/' + inc_file)), ' ')
            self.write('\n\t$(CY_COMP) -c -o $@ $<\n')

#----------------------- main() -----------------------#
args = Args()
opt = args.parse()

os.chdir(opt.cDir)
target = "unit"

rules = Rules()
rules.src_list = opt.srcDir
rules.inc_list = opt.incDir
rules.makefile = open('Makefile', 'w')
rules.write("#------------ Configs ------------#")

rules.write("CXX        = g++\n" +
            "COMP_FLAGS = -std=c++11 -fdiagnostics-color -DEXTENDED_FEATURE\n"+
            "CY_COMP    = $(CXX) $(COMP_FLAGS) $(INC)\n\n" +
            "INC := ", '')
for i in opt.incDir:
    rules.write(" \\\n    -I " + i, '')
rules.write('\n')

rules.write("OBJ_COMMON := " + os.path.relpath("obj", os.getcwd()[os.getcwd().rfind("unit/")+5:]) + "\n" +
            "OBJ_LOCAL  := obj\n\n" +
            "#------------ Targets ------------#\n" +
            "debug: COMP_FLAGS += -ggdb3\n" +
            "debug: all\n\n" +
            "coverage: CXX = g++-7\n" +
            "coverage: COMP_FLAGS += --coverage\n" +
            "coverage: all\n\n" +
            "mem-check: debug\n\n" +
            "perf: COMP_FLAGS += -ggdb3\n" +
            "perf: all\n\n" +
            "sanitize: COMP_FLAGS += -ggdb3 -D_FORTIFY_SOURCE=2 -D_GLIBCXX_DEBUG -D_GLIBCXX_DEBUG_PEDANTIC -fsanitize=address -fsanitize-address-use-after-scope -fsanitize=float-cast-overflow -fsanitize=leak -fsanitize=undefined -fsanitize-undefined-trap-on-error\n" +
            "sanitize: all\n")

rules.createRule('.', opt.file)
rules.write(target + ": " + ' '.join(rules.obj_list))
rules.write("\t$(CY_COMP) -o $@ $^\n")

dir_list = []
for obj in rules.obj_list:
    dir = os.path.dirname(obj)
    if dir not in dir_list:
        dir_list.append(dir)

rules.write("DIRS = " + ' '.join(dir_list) + "\n\n" +
            "all: $(DIRS) " + target + "\n")

rules.write("$(DIRS):")
rules.write("\tmkdir -p $@")

rules.write("\nclean: " + ' '.join(rules.obj_list))
rules.write("\t rm -f $^")
